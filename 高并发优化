详情页
  ↓
系统时间 → 倒计时*
   ↓         ↓
   地址暴露接口
       ↓
     秒杀操作
       ↓
      结果*
注：* 没有影响，其余部分可能出现高并发


为什么要单独获取系统时间（直接从服务器上获取系统时间）？→ 为高并发做铺垫

一、高并发点一：
    详情页分析：
        用户看到感兴趣的商品，如果没有开始，用户会很习惯的刷新页面。
        详情页应该部署到CDN节点上，CDN将detail页做静态化处理，静态资源也会部署到CDN上（也就是说，访问静态页和访问静态资源不用访问系统）
    CDN的理解：
        1、内容分发网络系统（加速用户获取数据的系统）
            可以是静态资源或者动态资源，完全取决于推送策略（比如视频资源就使用CDN加速用户获取资源的速度）
        2、CDN网络运营商的部署一般都会在离用户最近的网络节点上
        3、命中CDN不需要访问后台服务器
        4、互联网公司一般都会租用或者搭建自己的CDN集群

高并发点二：获取系统时间不用优化：
    访问一次内存大约10ns

三、高并发点三：秒杀地址接口分析：
    无法使用CDN缓存（CDN适合资源内容不变的东西）
    适合放在服务器端缓存（如redis等，可以扛很高的GPS）
    一致性维护成低（当秒杀的东西或秒杀的对象改变的时候，可以修改数据库或者修改缓存或者干脆超时后在改）
优化：
    请求地址 → redis（一致性维护，超时穿透/主动更新）
                 ↓
                mysql

四、高并发点四：秒杀操作优化分析
    无法使用CDN缓存（一般的写操作不适合使用CDN）
    后端缓存困难：库存问题（不一致问题）
    一行数据竞争：热点商品
其他方案分析：（常用方案架构）
    执行秒杀：（可以扛住非常高的并发）
    原子计数器（记录商品的库存） → redis/NoSQL
       ↓
    记录行为消息 → 分布式MQ（消息队列，作为消息放到分布式MQ当中）
       ↓
    消费消息并落地 → MySQL
痛点：
    运维成本和稳定性：NoSQL、MQ等
    开发成本：数据一致性、回滚方案等
    幂等性难保证：重复秒杀问题（减库存的时候不知道这个用户之前有没有减过库存）分布式方案：记录哪个用户已经秒杀过
    不适合新手的架构
为什么不用MySQL解决问题（是什么让MySQL低效）？
    其他用户无法获得行锁，串行化操作（大量阻塞）
    瓶颈分析：
        update减库存
          ↓网络延迟（sql语句发送给mysql、网络数据传回有延时）、GC
        insert购买明细
          ↓网络延迟、GC
        commit/rollback（行级锁在commit之后释放 → 优化方向：减少行级锁持有时间：把客户端逻辑放在MySQL服务器，避免网络延迟和GC影响）
        两种解决方案：
            定制SQL方案：update /* + [auto_commit] */，需要修改MySQL源码（不推荐，成本太高）
            使用存储过程：整个事务在MySQL端完成

优化总结：
    前端控制：暴露接口，按钮防重复
    动静态数据分离：CDN缓存、后端缓存
    事务竞争优化：减少事务锁时间

执行优化：
    优化1：redis做后台缓存优化地址暴露接口
    优化2：调整源码顺序：
        之前：减库存，成功，记录，失败（有两个延迟）
        之后：记录，减库存（只有一个延迟）
    优化3：深度优化——事务SQL在MySQL端执行（存储过程）
        报错：show create procedure execute_seckill\G
        错误信息：ERROR 1046 (3D000): No database selected
        正确：show create seckill.procedure execute_seckill\G（如果没指定数据库时使用）

        清屏操作：SYSTEM CLEAR（未生效）
        正确：


